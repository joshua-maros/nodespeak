block_comment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
line_comment = _{ "//" ~ (!"\n" ~ ANY)* ~ (EOI | "\n") }
COMMENT = _{ block_comment | line_comment }
WHITESPACE = _{ " " | "\t" | "\n" | "\r\n" }

dec_int = @{ (ASCII_DIGIT | "_")+ }
bin_int = @{ "0b" ~ (ASCII_BIN_DIGIT | "_")+ }
oct_int = @{ "0o" ~ (ASCII_OCT_DIGIT | "_")+ }
hex_int = @{ "0x" ~ (ASCII_HEX_DIGIT | "_")+ }
legacy_oct_int = @{ "0" ~ (ASCII_OCT_DIGIT | "_")+ }

int = _{ bin_int | hex_int | oct_int | legacy_oct_int | dec_int }
dec_digit = _{ ASCII_DIGIT | "_" }
float = @{
    (dec_digit* ~ "." ~ dec_digit+ ~ ("e" ~ ("+" | "-")? ~ dec_digit+)?)
    | (dec_digit+ ~ "." ~ ("e" ~ ("+" | "-")? ~ dec_digit+)?)
    | (dec_digit+ ~ "e" ~ ("+" | "-")? ~ dec_digit+)
}

literal = { float | int }

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Value Producing Expressions
vp_var = { identifier }

build_array = { "[" ~ (vpe ~ ("," ~ vpe)*)? ~ "]" }

vpe_part_1 = { literal | func_call | vp_var | "(" ~ vpe ~ ")" | build_array }

build_array_type = { ("[" ~ vpe ~ "]")+ ~ vpe_part_1 }

vp_index = { vpe_part_1 ~ ("[" ~ vpe ~ "]")+ }

negate = { "-" ~ (vpe_part_1 | vp_index) }

vpe_part_2 = _{ negate | build_array_type | vp_index | vpe_part_1 }

vpe_part = { vpe_part_2 }

// Operator precedence is done after parsing, because Pest uses an algorithm which chokes and
// slows down drastically if operator precedence is built in to the grammar.
operator = { 
    "**" | "*" | "//" | "/" | "%" | "+" | "-"
    | "<=" | ">=" | "<" | ">" | "==" | "!="
    | "band" | "bnand" | "bor" | "bnor" | "bxor" | "bxnor"
    | "and" | "nand" | "or" | "nor" | "xor" | "xnor"
}

vpe = { vpe_part ~ (operator ~ vpe_part)* }

// Value Consuming Expressions
var_dec = { vpe ~ identifier }
vc_identifier = { identifier }
vc_index = { vc_identifier ~ ("[" ~ vpe ~ "]")+ }
vce = { vc_index | var_dec | vc_identifier }

// Function calls

func_call_input_list = { "(" ~ (vpe ~ ("," ~ vpe)*)? ~ ")" }
inline_output = { "inline" }
func_call_output = _{ vce | inline_output }
func_call_output_list = { ":" ~ "(" ~ (func_call_output~ ("," ~ func_call_output)*)? ~ ")" }
func_call = { identifier ~ func_call_input_list ~ func_call_output_list? }

// Function definitions (techincally part of statements.)

named_function_parameter = { vpe ~ identifier }
function_inputs = { "(" ~ (
    named_function_parameter ~ ("," ~ named_function_parameter)*
)? ~ ")" }
function_outputs = { ":" ~ "(" ~ (
    named_function_parameter ~ ("," ~ named_function_parameter)*
)? ~ ")" }
single_function_output = { ":" ~ vpe }

function_signature = {
    (function_inputs ~ (function_outputs | single_function_output)?)
    | (function_outputs | single_function_output)?
}
function_definition = { 
    "fn" ~ identifier ~ function_signature ~ returnable_code_block 
}

// If statements.
else_if_clause = { "else" ~ "if" ~ vpe ~ code_block }
else_clause = { "else" ~ code_block }
if_statement = { "if" ~ vpe ~ code_block ~ (else_if_clause)* ~ (else_clause)? }

// For loop statements.
for_loop_statement = { "for" ~ identifier ~ "=" ~ vpe ~ "to" ~ vpe ~ code_block }

// Statements.
input_variable_statement = { "input" ~ vpe ~ identifier ~ ("," ~ identifier)* ~ ";" }
output_variable_statement = { "output" ~ vpe ~ identifier ~ ("," ~ identifier)* ~ ";" }
assign_statement = { vce ~ "=" ~ vpe ~ ";" }
func_call_statement = _{ func_call ~ ";" }
var_dec_statement = _{ var_dec ~ ";" }
return_statement = { "return" ~ (vpe ~ ("," ~ vpe)*)? ~ ";" }
assert_statement = { "assert" ~ vpe ~ ";" }

statement = { 
    function_definition | code_block | return_statement | assert_statement
    | if_statement | for_loop_statement
    | input_variable_statement | output_variable_statement 
    | assign_statement | func_call_statement | var_dec_statement
}

code_block = { "{" ~ statement* ~ "}" }
returnable_code_block = { "{" ~ statement* ~ vpe? ~ "}" }

root = { SOI ~ statement* ~ EOI }